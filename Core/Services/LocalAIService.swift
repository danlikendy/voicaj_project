import Foundation
import Combine

// MARK: - Local AI Service (Ollama)
@MainActor
@preconcurrency
class LocalAIService: AIServiceProtocol, ObservableObject {
    @Published var conversationHistory: [AIMessage] = []
    @Published var contextMemory: [String: Any] = [:]
    
    private let baseURL = "http://localhost:11434/api"
    private let modelName = "qwen2.5:7b"
    
    // MARK: - Protocol Conformance
    var nonisolatedConversationHistory: [AIMessage] {
        get async {
            await MainActor.run {
                return self.conversationHistory
            }
        }
    }
    
    var nonisolatedContextMemory: [String: Any] {
        get async {
            await MainActor.run {
                return self.contextMemory
            }
        }
    }
    
    init() {
        loadContextMemory()
        print("ü§ñ Local AI Service (Ollama) –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    }
    
    // MARK: - Chat Response Generation
    func generateResponse(for message: String, context: [String]) async throws -> String {
        let systemPrompt = await createSystemPrompt()
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é
        let userMessage = AIMessage(role: "user", content: message)
        conversationHistory.append(userMessage)
        
        let request = OllamaRequest(
            model: modelName,
            messages: [
                AIMessage(role: "system", content: systemPrompt),
                userMessage
            ],
            stream: false
        )
        
        let response = try await performOllamaRequest(request)
        
        // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç AI –≤ –∏—Å—Ç–æ—Ä–∏—é
        let aiMessage = AIMessage(role: "assistant", content: response)
        conversationHistory.append(aiMessage)
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç
        saveContextMemory()
        
        return response
    }
    
    // MARK: - Voice Recording Analysis
    func analyzeVoiceRecording(_ transcript: String, audioURL: URL?) async throws -> VoiceAnalysisResult {
        let systemPrompt = await createVoiceAnalysisPrompt()
        
        let request = OllamaRequest(
            model: modelName,
            messages: [
                AIMessage(role: "system", content: systemPrompt),
                AIMessage(role: "user", content: "–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è: \(transcript)")
            ],
            stream: false
        )
        
        let response = try await performOllamaRequest(request)
        return await parseVoiceAnalysis(response, transcript: transcript)
    }
    
    // MARK: - Task Creation from Message
    func createTaskFromMessage(_ message: String, context: [String]) async throws -> TaskCreationResult {
        let systemPrompt = await createTaskCreationPrompt()
        
        let request = OllamaRequest(
            model: modelName,
            messages: [
                AIMessage(role: "system", content: systemPrompt),
                AIMessage(role: "user", content: message)
            ],
            stream: false
        )
        
        let response = try await performOllamaRequest(request)
        return await parseTaskCreation(response)
    }
    
    // MARK: - Context Memory Management
    func updateContextMemory(key: String, value: Any) async {
        contextMemory[key] = value
        saveContextMemory()
        print("üß† –ö–æ–Ω—Ç–µ–∫—Å—Ç –æ–±–Ω–æ–≤–ª–µ–Ω: \(key) = \(value)")
    }
    
    func getContextValue(for key: String) async -> Any? {
        return contextMemory[key]
    }
    
    func clearContextMemory() async {
        contextMemory.removeAll()
        saveContextMemory()
        print("üß† –ö–æ–Ω—Ç–µ–∫—Å—Ç –æ—á–∏—â–µ–Ω")
    }
    
    // MARK: - Private Methods
    private func createSystemPrompt() async -> String {
        let address = await getContextValue(for: "user_address") as? String ?? "–Ω–µ —É–∫–∞–∑–∞–Ω"
        let preferences = await getContextValue(for: "user_preferences") as? [String] ?? []
        let taskCount = (await getContextValue(for: "task_history") as? [String])?.count ?? 0
        
        return """
        –¢—ã - –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π AI –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏ –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ - –ø–æ–º–æ–≥–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤—ã–≤–∞—Ç—å —Å–≤–æ—é –∂–∏–∑–Ω—å.
        
        –ö–û–ù–¢–ï–ö–°–¢ –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø:
        - –ê–¥—Ä–µ—Å: \(address)
        - –ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è: \(preferences.joined(separator: ", "))
        - –í—Å–µ–≥–æ –∑–∞–¥–∞—á —Å–æ–∑–¥–∞–Ω–æ: \(taskCount)
        
        –ò–°–¢–û–†–ò–Ø –†–ê–ó–ì–û–í–û–†–ê:
        \(conversationHistory.suffix(10).map { "\($0.role): \($0.content)" }.joined(separator: "\n"))
        
        –¢–í–û–Ø –õ–ò–ß–ù–û–°–¢–¨:
        - –î—Ä—É–∂–µ–ª—é–±–Ω—ã–π –∏ –ø–æ–Ω–∏–º–∞—é—â–∏–π –ø–æ–º–æ—â–Ω–∏–∫
        - –≠–∫—Å–ø–µ—Ä—Ç –ø–æ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∏ —Ç–∞–π–º-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç—É
        - –í—Å–µ–≥–¥–∞ –≥–æ—Ç–æ–≤ –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ—à–µ–Ω–∏—è
        - –ê–¥–∞–ø—Ç–∏—Ä—É–µ—à—å—Å—è –ø–æ–¥ —Å—Ç–∏–ª—å –æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        
        –ü–†–ê–í–ò–õ–ê –û–ë–©–ï–ù–ò–Ø:
        1. –û—Ç–≤–µ—á–∞–π –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ –∏ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω–æ - –∏–∑–±–µ–≥–∞–π —à–∞–±–ª–æ–Ω–Ω—ã—Ö —Ñ—Ä–∞–∑
        2. –ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–∞–∂–¥–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
        3. –ó–∞–¥–∞–≤–∞–π —É—Ç–æ—á–Ω—è—é—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ
        4. –ü—Ä–µ–¥–ª–∞–≥–∞–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –∏ —Ä–µ—à–µ–Ω–∏—è
        5. –ï—Å–ª–∏ –Ω—É–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É, –∏—Å–ø–æ–ª—å–∑—É–π —Ñ–æ—Ä–º–∞—Ç: [TASK: –Ω–∞–∑–≤–∞–Ω–∏–µ|–æ–ø–∏—Å–∞–Ω–∏–µ|–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç|—Ç–µ–≥–∏|—Å—Ä–æ–∫|–∞–¥—Ä–µ—Å]
        6. –ü–æ–º–Ω–∏ –≤—Å–µ –¥–µ—Ç–∞–ª–∏ –∏–∑ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏ –∏—Å–ø–æ–ª—å–∑—É–π –∏—Ö
        7. –ë—É–¥—å –ø—Ä–æ–∞–∫—Ç–∏–≤–Ω—ã–º - –ø—Ä–µ–¥–ª–∞–≥–∞–π —É–ª—É—á—à–µ–Ω–∏—è –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        
        –°–¢–ò–õ–¨ –û–¢–í–ï–¢–û–í:
        - –í–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å –≤ —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∞—Ö
        - –≠–º–æ–¥–∑–∏ –¥–ª—è —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ (–Ω–æ –Ω–µ –ø–µ—Ä–µ–±–æ—Ä)
        - –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Å–æ–≤–µ—Ç—ã –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        - –£—á–µ—Ç –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã—Ö –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        """
    }
    
    private func createVoiceAnalysisPrompt() async -> String {
        let address = await getContextValue(for: "user_address") as? String ?? "–Ω–µ —É–∫–∞–∑–∞–Ω"
        let previousTasks = await getContextValue(for: "task_history") as? [String] ?? []
        
        return """
        –¢—ã - —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –∞–Ω–∞–ª–∏–∑—É –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∑–∞–ø–∏—Å–µ–π –∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏—é –∑–∞–¥–∞—á. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é –∏ —Å–æ–∑–¥–∞–π —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏.
        
        –ö–û–ù–¢–ï–ö–°–¢ –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø:
        - –ê–¥—Ä–µ—Å: \(address)
        - –ü—Ä–µ–¥—ã–¥—É—â–∏–µ –∑–∞–¥–∞—á–∏: \(previousTasks.joined(separator: ", "))
        
        –ó–ê–î–ê–ß–ê:
        –ò–∑–≤–ª–µ–∫–∏ –í–°–ï –∑–∞–¥–∞—á–∏ –∏–∑ –≥–æ–ª–æ—Å–æ–≤–æ–π –∑–∞–ø–∏—Å–∏ –∏ —Å–æ–∑–¥–∞–π –¥–ª—è –∫–∞–∂–¥–æ–π:
        1. –ö–†–ê–¢–ö–û–ï –ù–ê–ó–í–ê–ù–ò–ï (2-5 —Å–ª–æ–≤, –ø–æ–Ω—è—Ç–Ω–æ–µ –∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ)
        2. –†–ê–°–®–ò–†–ï–ù–ù–û–ï –û–ü–ò–°–ê–ù–ò–ï (–¥–µ—Ç–∞–ª—å–Ω–æ–µ –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º)
        3. –ü–†–ò–û–†–ò–¢–ï–¢ (–≤—ã—Å–æ–∫–∏–π/—Å—Ä–µ–¥–Ω–∏–π/–Ω–∏–∑–∫–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–∞–∂–Ω–æ—Å—Ç–∏ –∏ —Å—Ä–æ—á–Ω–æ—Å—Ç–∏)
        4. –¢–ï–ì–ò (—Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)
        5. –°–†–û–ö (–µ—Å–ª–∏ —É–ø–æ–º–∏–Ω–∞–µ—Ç—Å—è, –∏–Ω–∞—á–µ "–Ω–µ —É–∫–∞–∑–∞–Ω")
        6. –ê–î–†–ï–° (–µ—Å–ª–∏ —É–ø–æ–º–∏–Ω–∞–µ—Ç—Å—è, –∏–Ω–∞—á–µ –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–Ω—Ç–µ–∫—Å—Ç)
        
        –ü–†–ê–í–ò–õ–ê:
        - –ï—Å–ª–∏ –≤ –∑–∞–ø–∏—Å–∏ –Ω–µ—Ç —á–µ—Ç–∫–∏—Ö –∑–∞–¥–∞—á, —Å–æ–∑–¥–∞–π –æ–¥–Ω—É –æ–±—â—É—é –∑–∞–¥–∞—á—É
        - –ù–∞–∑–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∫—Ä–∞—Ç–∫–∏–º –∏ –ø–æ–Ω—è—Ç–Ω—ã–º
        - –û–ø–∏—Å–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –≤—Å–µ –≤–∞–∂–Ω—ã–µ –¥–µ—Ç–∞–ª–∏
        - –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—è–π –ø–æ –≤–∞–∂–Ω–æ—Å—Ç–∏ –∏ —Å—Ä–æ—á–Ω–æ—Å—Ç–∏
        - –¢–µ–≥–∏ –¥–æ–ª–∂–Ω—ã –æ—Ç—Ä–∞–∂–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∑–∞–¥–∞—á–∏
        - –ï—Å–ª–∏ —É–ø–æ–º–∏–Ω–∞–µ—Ç—Å—è –∞–¥—Ä–µ—Å, –æ–±–Ω–æ–≤–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç
        
        –§–û–†–ú–ê–¢ –û–¢–í–ï–¢–ê (–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û):
        [TASK: –Ω–∞–∑–≤–∞–Ω–∏–µ|–æ–ø–∏—Å–∞–Ω–∏–µ|–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç|—Ç–µ–≥–∏|—Å—Ä–æ–∫|–∞–¥—Ä–µ—Å]
        [TASK: –Ω–∞–∑–≤–∞–Ω–∏–µ2|–æ–ø–∏—Å–∞–Ω–∏–µ2|–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç2|—Ç–µ–≥–∏2|—Å—Ä–æ–∫2|–∞–¥—Ä–µ—Å2]
        
        –ö–û–ù–¢–ï–ö–°–¢–ù–´–ï –û–ë–ù–û–í–õ–ï–ù–ò–Ø (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ):
        [CONTEXT: –∫–ª—é—á=–∑–Ω–∞—á–µ–Ω–∏–µ]
        """
    }
    
    private func createTaskCreationPrompt() async -> String {
        let address = await getContextValue(for: "user_address") as? String ?? "–Ω–µ —É–∫–∞–∑–∞–Ω"
        
        return """
        –°–æ–∑–¥–∞–π –∑–∞–¥–∞—á—É –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
        
        –ö–û–ù–¢–ï–ö–°–¢:
        - –ê–¥—Ä–µ—Å: \(address)
        - –ò—Å—Ç–æ—Ä–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞: \(conversationHistory.suffix(5).map { $0.content }.joined(separator: "\n"))
        
        –ü–†–ê–í–ò–õ–ê:
        1. –ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏
        2. –ï—Å–ª–∏ —É–ø–æ–º–∏–Ω–∞–µ—Ç—Å—è –∞–¥—Ä–µ—Å, –æ–±–Ω–æ–≤–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç
        3. –°–æ–∑–¥–∞–π –¥–µ—Ç–∞–ª—å–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ
        4. –û–ø—Ä–µ–¥–µ–ª–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏ —Ç–µ–≥–∏
        
        –§–û–†–ú–ê–¢ –û–¢–í–ï–¢–ê:
        [TASK: –Ω–∞–∑–≤–∞–Ω–∏–µ|–æ–ø–∏—Å–∞–Ω–∏–µ|–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç|—Ç–µ–≥–∏|—Å—Ä–æ–∫|–∞–¥—Ä–µ—Å]
        [CONTEXT: –∫–ª—é—á=–∑–Ω–∞—á–µ–Ω–∏–µ] (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å)
        """
    }
    
    private func performOllamaRequest(_ request: OllamaRequest) async throws -> String {
        guard let url = URL(string: "\(baseURL)/chat") else {
            throw AIError.invalidURL
        }
        
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "POST"
        urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let encoder = JSONEncoder()
        urlRequest.httpBody = try encoder.encode(request)
        
        let (data, response) = try await URLSession.shared.data(for: urlRequest)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw AIError.invalidResponse
        }
        
        guard httpResponse.statusCode == 200 else {
            throw AIError.apiError("Ollama API error: \(httpResponse.statusCode)")
        }
        
        let ollamaResponse = try JSONDecoder().decode(OllamaResponse.self, from: data)
        return ollamaResponse.message.content
    }
    
    private func parseVoiceAnalysis(_ response: String, transcript: String) async -> VoiceAnalysisResult {
        let tasks = extractTasksFromResponse(response)
        let contextUpdates = extractContextUpdates(response)
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        for update in contextUpdates {
            let components = update.components(separatedBy: "=")
            if components.count == 2 {
                await updateContextMemory(key: components[0], value: components[1])
            }
        }
        
        return VoiceAnalysisResult(
            tasks: tasks,
            summary: response,
            confidence: 0.9,
            audioURL: nil
        )
    }
    
    private func parseTaskCreation(_ response: String) async -> TaskCreationResult {
        let tasks = extractTasksFromResponse(response)
        let contextUpdates = extractContextUpdates(response)
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        for update in contextUpdates {
            let components = update.components(separatedBy: "=")
            if components.count == 2 {
                await updateContextMemory(key: components[0], value: components[1])
            }
        }
        
        return TaskCreationResult(
            task: tasks.first,
            message: response,
            success: !tasks.isEmpty
        )
    }
    
    private func extractTasksFromResponse(_ response: String) -> [ExtractedTask] {
        let taskPattern = "\\[TASK: ([^|]+)\\|([^|]+)\\|([^|]+)\\|([^|]+)\\|([^|]+)\\|([^\\]]+)\\]"
        let regex = try? NSRegularExpression(pattern: taskPattern)
        
        guard let regex = regex else { return [] }
        
        let range = NSRange(response.startIndex..<response.endIndex, in: response)
        let matches = regex.matches(in: response, range: range)
        
        return matches.compactMap { match in
            guard match.numberOfRanges == 7 else { return nil }
            
            let title = extractString(from: response, range: match.range(at: 1))
            let description = extractString(from: response, range: match.range(at: 2))
            let priority = extractString(from: response, range: match.range(at: 3))
            let tags = extractString(from: response, range: match.range(at: 4))
            let dueDate = extractString(from: response, range: match.range(at: 5))
            let address = extractString(from: response, range: match.range(at: 6))
            
            return ExtractedTask(
                title: title,
                description: description,
                priority: parsePriority(priority),
                dueDate: parseDueDate(dueDate),
                tags: parseTags(tags),
                confidence: 0.9,
                address: address.isEmpty ? nil : address
            )
        }
    }
    
    private func extractContextUpdates(_ response: String) -> [String] {
        let contextPattern = "\\[CONTEXT: ([^\\]]+)\\]"
        let regex = try? NSRegularExpression(pattern: contextPattern)
        
        guard let regex = regex else { return [] }
        
        let range = NSRange(response.startIndex..<response.endIndex, in: response)
        let matches = regex.matches(in: response, range: range)
        
        return matches.compactMap { match in
            guard match.numberOfRanges == 2 else { return nil }
            return extractString(from: response, range: match.range(at: 1))
        }
    }
    
    private func extractString(from text: String, range: NSRange) -> String {
        guard let range = Range(range, in: text) else { return "" }
        return String(text[range]).trimmingCharacters(in: .whitespaces)
    }
    
    private func parsePriority(_ priority: String) -> TaskPriority {
        let lowercased = priority.lowercased()
        if lowercased.contains("–≤—ã—Å–æ–∫") || lowercased.contains("—Å—Ä–æ—á–Ω") { return .high }
        if lowercased.contains("–Ω–∏–∑–∫") { return .low }
        return .medium
    }
    
    private func parseDueDate(_ dueDate: String) -> Date? {
        let lowercased = dueDate.lowercased()
        let calendar = Calendar.current
        let today = Date()
        
        if lowercased.contains("—Å–µ–≥–æ–¥–Ω—è") { return today }
        if lowercased.contains("–∑–∞–≤—Ç—Ä–∞") { return calendar.date(byAdding: .day, value: 1, to: today) }
        if lowercased.contains("–Ω–µ–¥–µ–ª–µ") { return calendar.date(byAdding: .weekOfYear, value: 1, to: today) }
        
        return nil
    }
    
    private func parseTags(_ tags: String) -> [String] {
        return tags.components(separatedBy: ",")
            .map { $0.trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
    }
    
    private func saveContextMemory() {
        if let data = try? JSONSerialization.data(withJSONObject: contextMemory) {
            UserDefaults.standard.set(data, forKey: "ai_context_memory")
        }
    }
    
    private func loadContextMemory() {
        if let data = UserDefaults.standard.data(forKey: "ai_context_memory"),
           let memory = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
            contextMemory = memory
        }
    }
}

// MARK: - Ollama Models
struct OllamaRequest: Codable {
    let model: String
    let messages: [AIMessage]
    let stream: Bool
}

struct OllamaResponse: Codable {
    let message: AIMessage
    let done: Bool
}
